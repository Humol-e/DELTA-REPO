#include <PIDController.hpp>
#include <QTRSensors.h>
#include "BluetoothSerial.h"
// --- DEFINICIÓN DE PINES (Revisa tus conexiones) ---
// Motor A (Izquierdo)
#define AIN1 21
#define AIN2 22
#define PWMA 23 
#define BIN1 18
#define BIN2 5
#define PWMB 4 
#define STBY 19


// --- CONFIGURACIÓN PID ---
// KP: Reacción rápida (Prueba subiendo si oscila poco, bajando si oscila mucho)
// KI: Acumula error (Déjalo bajo)
// KD: Predice el futuro (Súbelo si el robot tiembla mucho)
double Kp = 0.06;
double Ki = 0.01;
double Kd = 2.6;

// Inicializamos con los valores por defecto
PID::PIDParameters<double> parameters(Kp, Ki, Kd);
PID::PIDController<double> pidController(parameters);


// --- CONFIGURACIÓN QTR ---
QTRSensors qtr;
const uint8_t SensorCount = 8;
uint16_t sensorValues[SensorCount];

// --- VELOCIDADES ---
int baseSpeed = 45; // Velocidad crucero (0-255)
int maxSpeed = 75;  // Velocidad tope
int minSpeed = 30;  // Velocidad tope

const int pinEntrada = 15;

BluetoothSerial SerialBT;

void setup() {
  Serial.begin(115200);
    pinMode(pinEntrada, INPUT_PULLDOWN);

  // 1. Configurar Pines de Motores
  pinMode(AIN1, OUTPUT); pinMode(AIN2, OUTPUT); pinMode(PWMA, OUTPUT);
  pinMode(BIN1, OUTPUT); pinMode(BIN2, OUTPUT); pinMode(PWMB, OUTPUT);
  pinMode(STBY, OUTPUT);
  digitalWrite(STBY, HIGH); // Encender Driver

  // 2. Configurar Sensor QTR
  qtr.setTypeAnalog();
  qtr.setSensorPins((const uint8_t[]){35, 32, 33, 25, 26, 27, 14, 13}, SensorCount);
  
  // 3. Calibración
  Serial.println(">>> CALIBRANDO... MUEVE EL ROBOT <<<");
  for (uint16_t i = 0; i < 400; i++) {
    qtr.calibrate();
    delay(10);
  }
  Serial.println(">>> LISTO <<<");

  // 4. Iniciar PID
  pidController.Setpoint = 3500; // El centro de la línea para 8 sensores
  pidController.Input = 3500;
  pidController.SetOutputLimits(-40, 40); // El PID puede darnos corrección total
  pidController.TurnOn();
  
  delay(1000);
}

void loop() {
  // 1. Leer posición de la línea
  leerBluetooth(); // revisa bt

  uint16_t position = qtr.readLineBlack(sensorValues);

  // 2. Calcular PID
  pidController.Input = position;
  pidController.Update();
  double correction = pidController.Output;

  // 3. Aplicar corrección a la velocidad base
  // Si correction es positivo, el robot se fue a la izquierda -> Motor Izq sube, Der baja
  int motorA_Speed = baseSpeed + correction; 
  int motorB_Speed = baseSpeed - correction;

  int estado = digitalRead(pinEntrada);

  // 4. Mover motores (La función se encarga de limitar y dar dirección)
  if(estado == HIGH){
  moverMotores(motorA_Speed, motorB_Speed);

  // Debug (opcional, comenta para más velocidad)
  Serial.print("Pos: "); Serial.print(position);
  Serial.print(" | PID: "); Serial.print(correction);
  Serial.print(" | MotA: "); Serial.print(motorA_Speed);
  Serial.print(" | MotB: "); Serial.println(motorB_Speed);
  } else{
    moverMotores(0,0);
  }
}

// --- FUNCIÓN PARA LEER Y CAMBIAR VALORES POR BLUETOOTH ---
void leerBluetooth() {
  if (SerialBT.available()) {
    char comando = SerialBT.read(); // Leemos la letra (P, I, D, V)
    float valor = SerialBT.parseFloat(); // Leemos el número que sigue

    // Limpiamos el buffer por si quedan caracteres como saltos de linea
    while(SerialBT.available() > 0) { SerialBT.read(); }

    if (comando == 'P' || comando == 'p') {
      Kp = valor;
      parameters.Kp = Kp; // Actualizamos el objeto parameters
      SerialBT.print("Nuevo KP: "); SerialBT.println(Kp);
    }
    else if (comando == 'I' || comando == 'i') {
      Ki = valor;
      parameters.Ki = Ki;
      SerialBT.print("Nuevo KI: "); SerialBT.println(Ki);
    }
    else if (comando == 'D' || comando == 'd') {
      Kd = valor;
      parameters.Kd = Kd;
      SerialBT.print("Nuevo KD: "); SerialBT.println(Kd);
    }
    else if (comando == 'V' || comando == 'v') {
      baseSpeed = (int)valor;
      SerialBT.print("Nueva Velocidad Base: "); SerialBT.println(baseSpeed);
    }
    
    // IMPORTANTE: Dependiendo de tu librería PIDController exacta, 
    // tal vez necesites llamar a una función para refrescar los cambios.
    // Si la librería lee 'parameters' por referencia, esto es automático.
    // Si no, intenta descomentar algo como: 
    // pidController.SetTunings(parameters); 
  }
}


// Esta función recibe la velocidad (-255 a 255) y decide la dirección
void moverMotores(int speedA, int speedB) {
  // Limitar rangos a +/- maxSpeed
  speedA = constrain(speedA, minSpeed, maxSpeed);
  speedB = constrain(speedB, minSpeed, maxSpeed);

  // --- MOTOR A ---
  if (speedA > 0) {
    digitalWrite(AIN1, LOW); digitalWrite(AIN2, HIGH); // Adelante
  } else {
    digitalWrite(AIN1, HIGH); digitalWrite(AIN2, LOW); // Atrás
    speedA = speedA; // Convertir a positivo para el PWM
  }
  analogWrite(PWMA, speedA);

  // --- MOTOR B ---
  if (speedB > 0) {
    digitalWrite(BIN1, LOW); digitalWrite(BIN2, HIGH); // Adelante
  } else {
    digitalWrite(BIN1, HIGH); digitalWrite(BIN2, LOW); // Atrás
    speedB = speedB; // Convertir a positivo
  }
  analogWrite(PWMB, speedB);
}
