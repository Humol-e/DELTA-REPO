#include <PIDController.hpp>
#include <QTRSensors.h>
#include "BluetoothSerial.h"
// --- DEFINICIÓN DE PINES (Revisa tus conexiones) ---
// Motor A (Izquierdo)
#define AIN1 21
#define AIN2 22
#define PWMA 23
#define BIN1 18
#define BIN2 5
#define PWMB 4
#define STBY 19

bool pedirLectura = false;  // agrega esto global arriba

int offsetA = 0;
int offsetB = 0;

int currentSpeedA = 0;
int currentSpeedB = 0;
int rampStep = 5;  // qué tan rápido acelera motor, prueba entre 3 y 10


// --- CONFIGURACIÓN PID ---
// KP: Reacción rápida (Prueba subiendo si oscila poco, bajando si oscila mucho)
// KI: Acumula error (Déjalo bajo)
// KD: Predice el futuro (Súbelo si el robot tiembla mucho)
double Kp = 0.1;
double Ki = 0;
double Kd = 0;

// Inicializamos con los valores por defecto
PID::PIDParameters<double> parameters(Kp, Ki, Kd);
PID::PIDController<double> pidController(parameters);


// --- CONFIGURACIÓN QTR ---
QTRSensors qtr;
const uint8_t SensorCount = 8;
uint16_t sensorValues[SensorCount];

// --- VELOCIDADES ---
int baseSpeed = 70;  // Velocidad crucero (0-255)
int maxSpeed = 100;  // Velocidad tope
int minSpeed = 15;   // Velocidad tope

const int pinEntrada = 15;

BluetoothSerial SerialBT;

void setup() {
  Serial.begin(115200);

  // 1. Configurar Pines de Motores
  pinMode(AIN1, OUTPUT);
  pinMode(AIN2, OUTPUT);
  pinMode(PWMA, OUTPUT);
  pinMode(BIN1, OUTPUT);
  pinMode(BIN2, OUTPUT);
  pinMode(PWMB, OUTPUT);
  pinMode(STBY, OUTPUT);
  digitalWrite(STBY, HIGH);  // Encender Driver
  analogReadResolution(10);

  // 2. Configurar Sensor QTR
  qtr.setTypeAnalog();
  qtr.setSensorPins((const uint8_t[]){ 35, 32, 33, 25, 26, 27, 14, 13 }, SensorCount);

  // 3. Calibración
  Serial.println(">>> CALIBRANDO... MUEVE EL ROBOT <<<");
  for (uint16_t i = 0; i < 400; i++) {
    qtr.calibrate();
    delay(10);
  }
  Serial.println(">>> LISTO <<<");
  SerialBT.begin("ESP32_Robot_PID");
  pinMode(pinEntrada, INPUT_PULLDOWN);

  // 4. Iniciar PID
  pidController.Setpoint = 3500;  // El centro de la línea para 8 sensores
  pidController.Input = 3500;
  pidController.SetOutputLimits(-100, 100, -40, 40);  // El PID puede darnos corrección total
  pidController.TurnOn();

  delay(1000);
}

void loop() {
  // 1. Leer posición de la línea
  leerBluetooth();  // revisa bt

  uint16_t position = qtr.readLineBlack(sensorValues);

  // 2. Calcular PID
  pidController.Input = position;
  pidController.Update();
  double correction = pidController.Output;

  // 3. Aplicar corrección a la velocidad base
  // Si correction es positivo, el robot se fue a la izquierda -> Motor Izq sube, Der baja
  int motorA_Speed = baseSpeed + correction + offsetA;
  int motorB_Speed = baseSpeed - correction + offsetB;


  int estado = digitalRead(pinEntrada);

  // 4. Mover motores (La función se encarga de limitar y dar dirección)
  int targetA = constrain(motorA_Speed, minSpeed, maxSpeed);
  int targetB = constrain(motorB_Speed, minSpeed, maxSpeed);

  if (estado == HIGH) {
    if (currentSpeedA < targetA) currentSpeedA = min(currentSpeedA + rampStep, targetA);
    else if (currentSpeedA > targetA) currentSpeedA = max(currentSpeedA - rampStep, targetA);

    if (currentSpeedB < targetB) currentSpeedB = min(currentSpeedB + rampStep, targetB);
    else if (currentSpeedB > targetB) currentSpeedB = max(currentSpeedB - rampStep, targetB);

    moverMotores(currentSpeedA, currentSpeedB);
    // Debug (opcional, comenta para más velocidad)
    /*Serial.print("Pos: ");
    Serial.print(position);
    Serial.print(" | PID: ");
    Serial.print(correction);
    Serial.print(" | MotA: ");
    Serial.print(motorA_Speed);
    Serial.print(" | MotB: ");
    Serial.println(motorB_Speed);
    */
  } else {
    /*Serial.print("Pos: ");
    Serial.print(position);
    Serial.
    


    
    moverMotores(0, 0);
  }
  if (pedirLectura) {
    pedirLectura = false;  // reset del flag

    int motA = constrain(motorA_Speed, minSpeed, maxSpeed);
    int motB = constrain(motorB_Speed, minSpeed, maxSpeed);

    SerialBT.println("=========================");
    SerialBT.print("| ");
    for (int i = 0; i < SensorCount; i++) {
      SerialBT.print("S");
      SerialBT.print(i);
      SerialBT.print(":");
      SerialBT.print(sensorValues[i]);
      SerialBT.print(" | ");
    }
    SerialBT.println();
    SerialBT.print("Posicion  : ");
    SerialBT.println(position);
    SerialBT.print("Correccion: ");
    SerialBT.println(correction);
    SerialBT.print("Motor A   : ");
    SerialBT.println(motA);
    SerialBT.print("Motor B   : ");
    SerialBT.println(motB);
    SerialBT.println("=========================");
  }
}

// --- FUNCIÓN PARA LEER Y CAMBIAR VALORES POR BLUETOOTH ---
void leerBluetooth() {
  if (SerialBT.available()) {
    char comando = SerialBT.read();
    delay(10);                             // pequeña espera para que llegue el número
                                           // Leemos la letra (P, I, D, V)
    double valor = SerialBT.parseFloat();  // Leemos el número que sigue

    // Limpiamos el buffer por si quedan caracteres como saltos de linea
    while (SerialBT.available() > 0) { SerialBT.read(); }

    if (comando == 'P' || comando == 'p') {
      Kp = valor;
      parameters.Kp = Kp;  // Actualizamos el objeto parameters
      SerialBT.print("Nuevo KP: ");
      SerialBT.println(Kp);
    } else if (comando == 'I' || comando == 'i') {
      Ki = valor;
      parameters.Ki = Ki;
      SerialBT.print("Nuevo KI: ");
      SerialBT.println(Ki);
    } else if (comando == 'D' || comando == 'd') {
      Kd = valor;
      parameters.Kd = Kd;
      SerialBT.print("Nuevo KD: ");
      SerialBT.println(Kd);
    } else if (comando == 'V' || comando == 'v') {
      baseSpeed = (int)valor;
      SerialBT.print("Nueva Velocidad Base: ");
      SerialBT.println(baseSpeed);
    } else if (comando == 'A' || comando == 'a') {
      offsetA = (int)valor;
      SerialBT.print("Offset A: ");
      SerialBT.println(offsetA);
    } else if (comando == 'B' || comando == 'b') {
      offsetB = (int)valor;
      SerialBT.print("Offset B: ");
      SerialBT.println(offsetB);
    } else if (comando == 'L' || comando == 'l') {
      pedirLectura = true;
    } else if (comando == 'C' || comando == 'c') {
      // Recalibrar
      SerialBT.println(">>> CALIBRANDO... MUEVE EL ROBOT <<<");
      for (uint16_t i = 0; i < 400; i++) {
        qtr.calibrate();
        delay(10);
      }
      SerialBT.println(">>> LISTO <<<");
    }

    parameters.Kp = Kp;
    parameters.Ki = Ki;
    parameters.Kd = Kd;
    pidController.SetTunings(parameters);
  }
}


// Esta función recibe la velocidad (-255 a 255) y decide la dirección
void moverMotores(int speedA, int speedB) {

  // Si speed es 0 (cuando frenamos), apagamos PWM para evitar zumbidos
  if (speedA == 0 && speedB == 0) {
    analogWrite(PWMA, 0);
    analogWrite(PWMB, 0);
    return;
  }
  speedA = constrain(speedA, minSpeed, maxSpeed);
  speedB = constrain(speedB, minSpeed, maxSpeed);

  // Motor A
  if (speedA > 0) {
    digitalWrite(AIN1, LOW);
    digitalWrite(AIN2, HIGH);
  } else {
    digitalWrite(AIN1, HIGH);
    digitalWrite(AIN2, LOW);
    speedA = abs(speedA);
  }
  analogWrite(PWMA, speedA);

  // Motor B
  if (speedB > 0) {
    digitalWrite(BIN1, LOW);
    digitalWrite(BIN2, HIGH);
  } else {
    digitalWrite(BIN1, HIGH);
    digitalWrite(BIN2, LOW);
    speedB = abs(speedB);
  }
  analogWrite(PWMB, speedB);
}
